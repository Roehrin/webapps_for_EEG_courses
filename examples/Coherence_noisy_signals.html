<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coherence-based connectivity</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script type="text/javascript" id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0px;
        }
        .slider {
            margin: 10px 0;
        }
		.banner {
		  position: sticky;
		  top: 0;
		  background:#96004B;
		  color: #f1f1f1;
		  z-index: 1;
		  text-align: right;
		  padding: 10px
		}
		.divfooter {
		  top: 0;
		  background: #555;
		  color: #f1f1f1;
		}
		.text {
		  text-align: right;
		}
		.div {
		  margin: 20px;
		}
		section {
			margin: 30px;
		}
		h1 {
			margin: 10px;
		}
    </style>
</head>
<body>
	<div class="banner">
			<img src="https://www.unige.ch/cdn/themes/unige2016/img/unige-logo.svg">
			<br>&copy; 2025 Dr Nicolas Roehri
	</div>
	<h1>Coherence-based connectivity</h1>
	<p>
	<section>
	<h2>Introduction</h2>
	<h3>Definition</h3>
	<h3>Key concept</h3>
	</section>
	<section>
	<h2>Example: Computing the Coherence (Coh)</h2>
	Let us assume two noisy oscillating signals \(S_1\) and \(S_2\) of amplitudes \(A_1\) and \(A_2\), frequencies \(f_1\) and \(f_2\), and phase shifts \(\theta_1\) and \(\theta_2\), respectively. These signals are can be written as:
	$$S_1(t) = A_1\cos(2\pi f_1t + \theta_1) + \epsilon_1(t), and$$ $$S_2(t) = A_2\cos(2\pi f_2t + \theta_2) + \epsilon_2(t)$$ $$\epsilon_i \sim \mathcal{N}(0,\sigma^{2}).$$
	\(f_1\), \(\theta_1\) and \(A\) are fixed, \(f_1 = 10\textrm{ Hz}, \theta_1=0\textrm{ rad}\), \(t\) is the time. <br>
	\(A_1\), \(A_2\), \(f_2\), \(\theta_2\) and \(\sigma\) are user defined.
	</section>
	<section>
	The Coherence (Coh) measures the consistency of both phase and power correlations between two signals, ranging from 0 (no synchrony) to 1 (perfect synchrony).
	$$\text{Coh} = \frac{\left| \sum_{t=1}^{N} \tilde{S_1}(t) \tilde{S_2}^{*}(t) \right|}{\sqrt{\sum_{t=1}^{N} \left| \tilde{S_1}(t) \right|^2 \sum_{t=1}^{N} \left| \tilde{S_2}(t) \right|^2}}$$
	$$\text{Coh} = \frac{\left| \sum_{t=1}^{N} A_1(t)e^{i\phi_1(t)} A_2(t)e^{-i\phi_2(t)} \right|}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}}$$
	$$\text{Coh} = \frac{\left| \sum_{t=1}^{N} A_1(t)A_2(t)e^{i\Delta\phi_{1,2}(t)} \right|}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}}$$<br>
	\(N\) is the total number of time points, \(\Delta\phi_{1,2}\) the phase difference, and \(\left| . \right|\)the absolute value.<br>
	$$\Phi_{\text{Coh}} = \arg \left( \frac{ \sum_{t=1}^{N} A_1(t)A_2^*(t)e^{i\Delta\phi_{1,2}(t)}}{\sqrt{\sum_{t=1}^{N} A_1^2(t) \sum_{t=1}^{N} A_2^2(t)}} \right)$$
	\(\arg(.)\) is the argument function, which gives the phase angle of the complex mean phase difference.<br>
	\(\Phi_{\text{Coh}}\) represents the preferred phase difference.<br>
	One can represent both information as a phasor, using the complex valued coherence (before applying \(\left| . \right|\) in a polar plot, where its radius would be the \(\text{Coh}\) and \(\Phi_{\text{Coh}}\) its angle.	
	<p>
	<h3>Case 1: constant amplitude</h3>
	As a first example, let us define \(A_1=A_2=A=1\).
	The plot below let you modify \(f_2\), \(\theta_2\) and \(\sigma\) and see their effect on the \(\text{Coh}\).
	</section>
    <div id="plot" style="width:100%;height:600px;"></div>
	<div class="divfooter" id="myDivFooter">
		<span style="padding: 5px">
			<label for="frequency">\(f_2\) :</label>
			<input type="range" id="frequency" class="slider" min="1" max="25" value="10">
			<span id="freqValue">10 Hz</span>
		</span>
		<span style="padding: 5px">
			<label for="phase">\(\theta_2\) :</label>
			<input type="range" id="phase" class="slider" min="-175" max="180" value="0" step="5">
			<span id="phaseValue">0 rad</span>
		</span>
		<span style="padding: 5px">
			<label for="noiseLevel">\(\sigma\) :</label>
			<input type="range" id="noiseLevel" class="slider" min="0" max="1" value="0.1" step="0.01">
			<span id="noiseValue">0.1</span>
		</span>
		<span style="padding: 5px">
		Show: 
		<input type="checkbox" id="showCoh" checked /><label for="showCoh">Coh</label>
		<input type="checkbox" id="showiCoh"/><label for="showiCoh">iCoh</label>
		<input type="checkbox" id="showciCoh"/><label for="showicCoh">ciCoh</label>
		</span>
    </div>
	<section>
	<h3>Case 2: TODO</h3>
	<h3>Case 3: TODO</h3>
	</section>
	<section>
	<h2>Version of the Phase Locking Value robust to spatial leakage.</h2>
	In case of spatial leakage (signal mixing), such in Electrical Source Imaging, \(S_1\) and \(S_2\) can be spuriously correlated. However, this spurious correlation is instantaneous and thus occurs at 0-lag. One way to compensate for that is by removing the contribution to the 0-lag in the computation of the Coh. Importantly, 0-lag means that the phase difference equals 0. Any contribution at 0-lag happens on the real axis. Therefore the imaginary part of the Coh is defined as:
	$$\text{iCoh} = \Im\left( \mathcal{P}_{\text{Coh}} \right)$$<br>
	\(\Im\) is the imaginary part. 
	This metric is now robust to spurious 0-lag but also removes any genuine 0-lag. We cannot, however, estimate the true preferred phase due to the mixing. Intuitively, \(\text{iCoh}\) is the projection of the \(\text{Coh}\) phasor onto the imaginary axis. Check the \(\text{iCoh}\) box, and see how this metric behaves according to different changes in phase and noise.
	<br>
	<br>
	Unfortunately, \(\text{iCoh}\) is sensitive to the preferred phase difference \(\Phi_{\text{Coh}}\). A corrected version of \(\text{iCoh}\), named corrected iCoh, mitigates this effect and is defined as:
	$$\text{ciCoh} = \frac{\Im\left( \mathcal{P}_{\text{Coh}}\right)}{\sqrt{1-\Re\left( \mathcal{P}_{\text{Coh}} \right)^2}}$$<br>
	\(\Re\) is the real part.<br>
	Check the \(\text{ciCoh}\) box, and see how this metric behaves according to different changes in phase and noise.
	</section>
	
	
    <script type="module" async>
		import {computeDFT, generateGaussianNoise, analyticSignal} from 'https://roehrin.github.io/webapps_for_EEG_courses/js-scripts/simpleSignalProcessing.js';
        
		const checkboxes = document.querySelectorAll('input[type=checkbox]');
		
        const sampleRate = 512;
		const freq1 = 10;
		const phase1 = 0;
		var freq2 = parseFloat(document.getElementById("frequency").value);
		var phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
		var noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
        const time = Array.from({ length: sampleRate }, (_, i) => i / sampleRate);
		const N = time.length;
		
		var w1 = .65;
		var w2 = .25;
		var w3 = .05;
		var wgap = .05;
		// normalise the ws to ensure the sum equals 1
		let wnorm = w1 + w2 + w3 + 2*wgap;
		w1 = w1/wnorm; w2 = w2/wnorm; wgap = wgap/wnorm;
		
        
		// Generate noise
		var noise1 = generateGaussianNoise(noiseLvl, time.length); // Noise for first channel
		var noise2 = generateGaussianNoise(noiseLvl, time.length); // Second sine wave
		
		// Generate sine waves
		var sineWave1 = generateSineWave(freq1, phase1, noise1); // First sine wave
		var sineWave2 = generateSineWave(freq2, phase2, noise2); // Second sine wave
		
		// compute analytic signal
		var zWave1 = analyticSignal(sineWave1); // First sine wave
		var zWave2 = analyticSignal(sineWave2); // Second sine wave
		
		// compute sample Coh
		var sampleCoh = computeSampleCoh(zWave1, zWave2);
		
        function generateSineWave(frequency, phase, noise) {
            return time.map((t, index) => Math.cos(2 * Math.PI * frequency * t + phase) + noise[index]);
        }
		
		frequency.oninput = function () {
			freq2 = parseFloat(document.getElementById("frequency").value);
			document.getElementById("freqValue").textContent = freq2 + " Hz";
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}
		
		phase.oninput = function () {
			phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
			document.getElementById("phaseValue").textContent = phase2.toFixed(2) + " rad";
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}
		
		noiseLevel.oninput = function () {
			noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
			document.getElementById("noiseValue").textContent = noiseLvl.toFixed(2);
			
			noise1 = generateGaussianNoise(noiseLvl, time.length);
			sineWave1 = generateSineWave(freq1, phase1, noise1);
			zWave1 = analyticSignal(sineWave1);
			
			noise2 = generateGaussianNoise(noiseLvl, time.length);
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			updatePlots()
		}
		

        function updatePlots() {        
            
			sampleCoh = computeSampleCoh(zWave1, zWave2);
			const Coh = computeCoherence(zWave1, zWave2)
			const iCoh = computeImCoh(Coh);
			const ciCoh = computecImCoh(Coh)
			// to compute the angle diff we have to pass again to the complex values to stay within [-pi, pi]
			const angleDiff = 0; 
            // Create traces for time domain signals
            const timeTrace1 = {
                x: time,
                y: sineWave1,
                mode: 'lines',
				type: 'scatter',
                name: 'Signal 1',
                line: { color: 'black' }
            };

            const timeTrace2 = {
                x: time,
                y: sineWave2,
                mode: 'lines',
                name: 'Signal 2',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'}
            };



            // Create scatter plot trace
            const scatterTrace = {
				type: "scatterpolar",
				r: sampleCoh.sampleMagn,
				theta: sampleCoh.samplePhase,
				mode: "markers",
				marker: {
					color: 'brown',//"#2255ff",
					size: 10,
					line: {
					  color: "white"
					},
					opacity: 0.1
				},
				thetaunit: "radians",
				cliponaxis: true,
				subplot: "polar",
				name: "sample coh.",
			};
			
			// Create bar plot for correlation
			const CohPlot = [{
				type: "scatterpolar",
				name: `Coh (r = ${Coh.magnitude.toFixed(2)})`,
				r: [0, Coh.magnitude],
				theta: [0, Coh.preferredPhase],
				marker: {
					color: "orange",
					symbol: "square",
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showCoh.checked,
			},
			{
				type: "scatterpolar",
				name: `iCoh (r = ${iCoh.magnitude.toFixed(2)})`,
				r: [0, iCoh.magnitude],
				theta: [0, iCoh.preferredPhase],
				marker: {
					color: "green",
					symbol: 121,
					line: {
						width: 3
					},
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",				
				visible: showiCoh.checked,
			},
			{
				type: "scatterpolar",
				name: `ciCoh (r = ${ciCoh.magnitude.toFixed(2)})`,
				r: [0, ciCoh.magnitude],
				theta: [0, ciCoh.preferredPhase],
				marker: {
					color: "purple",
					symbol: 121,
					line: {
						width: 3
					},
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showciCoh.checked,
			}
			];
			
			// Define metric data
			const metricsData = {
				Coh: Coh.magnitude,
				iCoh: iCoh.magnitude,
				ciCoh: ciCoh.magnitude
			};
			
			var barValues = [];
			var barText = [];
			
			checkboxes.forEach(checkbox => {
				if (checkbox.checked) {
					barValues.push(metricsData[checkbox.id.substr(4)]);  // Store metric name
					barText.push(checkbox.id.substr(4)); // Store corresponding values
				}
			});
			
			// Create bar plot for correlation
			const barPlot = {
				x: barText,
				y: barValues,
				type: 'bar',
				xaxis: 'x3',
				yaxis: 'y3',
				name: 'Bar Plot',
				marker:{
					color: ['orange', 'green', 'purple']
				},
				showlegend: false
			};
			
            // Define subplots layout
            const layout = {
                //grid: { rows: subplotRows, columns: subplotCols, pattern: 'independent' },
				// time domain
                xaxis: { domain: [0, w1], anchor: 'y1'},
                yaxis: { title: 'Amplitude', domain: [0, 1], anchor: 'x1', range: [-2, 2]},
				// bar plot
				xaxis3: { domain: [w1+w2+wgap, 1], anchor: 'y3'},
                yaxis3: { title: 'Magnitude', domain: [0, 1], side: 'right', anchor: 'x3', range: [0, 1]},
				
				// polar scatter
				polar: {domain: {x: [w1+wgap, w1+w2], y: [0, 1]}, angularaxis: {thetaunit: "radians"}, radialaxis: {range: [0, 2]}},
				showlegend: true,
				font: { size: 16 },
				legend: {x: 0, xanchor: 'left', y: 1, orientation: "h", font: { size: 16 }}
            };

            // Combine all traces into a single data array
            var combinedData = [
                timeTrace1,
                timeTrace2,
				scatterTrace,
				barPlot
            ];
			combinedData = combinedData.concat(CohPlot);

            // Update the plot
            Plotly.newPlot('plot', combinedData, layout, {responsive: true});
        }

        // Initial plot
        updatePlots();
		
		checkboxes.forEach(checkbox => {
            checkbox.addEventListener('click', updatePlots);
        });
				
		
		function computeSampleCoh(analytic1, analytic2) {
			// compute power
			const power1 = zWave1.reduce((sum, [re, im]) => sum + (re ** 2 + im ** 2), 0); // First sine wave
			const power2 = zWave2.reduce((sum, [re, im]) => sum + (re ** 2 + im ** 2), 0); // Second sine wave
			
			let sampleMagn = zWave1.map(([real, imag]) => N*(real ** 2 + imag ** 2)/Math.sqrt(power1 * power2));				
			let samplePhase = zWave1.map(([real, imag], i) => Math.atan2(imag * zWave2[i][0] - real * zWave2[i][1], real * zWave2[i][0] + imag * zWave2[i][1] ));
			
			return {sampleMagn, samplePhase};
		}
		function computeCoherence(analytic1, analytic2) {
			if (analytic1.length !== analytic2.length) {
				throw new Error("Signals must have the same length.");
			}

			let N = analytic1.length;
			let coh = 0;
			let sumCrossRe = 0;
			let sumCrossIm = 0;
			let sumPower1 = 0;
			let sumPower2 = 0;
			
			for (let t = 0; t < N; t++) {
			
				// Analytic signal components
				let re1 = analytic1[t][0], im1 = analytic1[t][1];
				let re2 = analytic2[t][0], im2 = analytic2[t][1];

				// Compute cross-spectral real and imaginary parts
				sumCrossRe += re1 * re2 + im1 * im2;  // Real part of A1 * conj(A2)
				sumCrossIm += im1 * re2 - re1 * im2;  // Imaginary part of A1 * conj(A2)
				
				sumPower1 += re1 ** 2 + im1 ** 2;
				sumPower2 += re2 ** 2 + im2 ** 2;
	
			}
			
			// Compute coherence magnitude
			let crossMag = Math.sqrt(sumCrossRe ** 2 + sumCrossIm ** 2);
			let magnitude = crossMag / Math.sqrt(sumPower1 * sumPower2);
			// Compute preferred phase difference
			let preferredPhase = Math.atan2(sumCrossIm, sumCrossRe);

			return {magnitude, preferredPhase};
		}
		
		function computeImCoh(Coh) {

			let magnitude = Math.abs(Coh.magnitude * Math.sin(Coh.preferredPhase)); // imCoh magnitude
			let preferredPhase = Math.sign(Math.sin(Coh.preferredPhase)) * Math.PI/2; // imCoh phase
			return { magnitude, preferredPhase};
		}

		function computecImCoh(Coh) {
			let numerator = Math.abs(Coh.magnitude * Math.sin(Coh.preferredPhase));
			let denominator = Math.sqrt(1 -  Math.pow(Coh.magnitude * Math.cos(Coh.preferredPhase),2));
			let magnitude = (denominator === 0) ? 0 : (numerator/denominator); // cimCoh magnitude
			let preferredPhase = Math.sign(Math.sin(Coh.preferredPhase)) * Math.PI/2; // cimCoh phase locking
			return { magnitude, preferredPhase};
		}

    </script>
</body>
</html>
