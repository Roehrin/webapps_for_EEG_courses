<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Locking Value correlation of two noisy signals</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script type="text/javascript" id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0px;
        }
        .slider {
            margin: 10px 0;
        }
		.banner {
		  position: sticky;
		  top: 0;
		  background:#96004B;
		  color: #f1f1f1;
		  z-index: 1;
		  text-align: right;
		  padding: 10px
		}
		.divfooter {
		  top: 0;
		  background: #555;
		  color: #f1f1f1;
		}
		.text {
		  text-align: right;
		}
		.div {
		  margin: 20px;
		}
		section {
			margin: 30px;
		}
		h1 {
			margin: 10px;
		}
    </style>
</head>
<body>
	<div class="banner">
			<img src="https://www.unige.ch/cdn/themes/unige2016/img/unige-logo.svg">
			<br>&copy; 2025 Dr Nicolas Roehri
	</div>
	<h1>Phased-based connectivity</h1>
	<p>
	<section>
	<h2>Introduction</h2>
	<h3>Definition</h3>
	Phase-based connectivity is a measure of the functional connectivity between two or more signals based on the synchronisation of their instantaneous phase dynamics rather than their amplitude or power. It is commonly used in neuroscience and signal processing to analyse oscillatory interactions between brain regions, usually using EEG, MEG or LFP signals.
	<h3>Key concept</h3>
	Two signals are considered to be phase-coupled if their instantaneous phase differences remain coherent over time, even if their amplitudes fluctuate. This suggests a functional interaction between the underlying sources that generate these signals.
	</section>
	<section>
	<h2>Example: Computing the Phase-Locking Value (PLV)</h2>
	Let us assume two noisy oscillating signals \(S_1\) and \(S_2\) of constant amplitude \(A\), frequencies \(f_1\) and \(f_2\), and phase shifts \(\theta_1\) and \(\theta_2\), respectively. These signals are can be written as:
	$$S_1(t) = A\cos(2\pi f_1t + \theta_1) + \epsilon_1(t), and$$ $$S_2(t) = A\cos(2\pi f_2t + \theta_2) + \epsilon_2(t)$$ $$\epsilon_i \sim \mathcal{N}(0,\sigma^{2}).$$
	\(f_1\), \(\theta_1\) and \(A\) are fixed, \(f_1 = 10\textrm{ Hz}, \theta_1=0\textrm{ rad}, A=1\), \(t\) is the time. <br>
	\(f_2\), \(\theta_2\) and \(\sigma\) are user defined.
	</section>
	<section>
	To compute phased-based connectivity metric between \(S_1\) and \(S_2\), we need to estimate a phase. Here we will use the instantaneous phase given by their analytic signal (\(\tilde{S_1}\) and \(\tilde{S_2}\)). Thanks to the Hilbert transform (\(\mathcal{H}(.)\)), we obtain:
	$$\tilde{S_1}(t)= S_1(t)+i\mathcal{H}(S_1(t)) = Ae^{i(2\pi f_1t + \theta_1)} + \tilde{\epsilon_1}(t),$$
	$$\tilde{S_2}(t)= Ae^{i(2\pi f_2t + \theta_2)} + \tilde{\epsilon_1}(t).$$
	The instantaneous phase is defined as:
	$$\phi_i(t)= 2\pi f_it + \theta_i,$$
	$$\textrm{so }\tilde{S_1}(t)= Ae^{i\phi_1(t)} + \tilde{\epsilon_1}(t), \textrm{ and } \tilde{S_2}(t)= Ae^{i\phi_2(t)} + \tilde{\epsilon_2}(t),$$<br>
	The Phase Locking Value (PLV) is a measure of phase synchrony between two signals, independent of the amplitude of the signal.
	$$\text{PLV} = \left| \frac{1}{N} \sum_{t=1}^{N} e^{i (\phi_1(t) - \phi_2(t))} \right|$$
	$$\text{or, PLV} = \left| \frac{1}{N} \sum_{t=1}^{N} e^{i \Delta\phi_{1,2}(t)} \right|$$<br>
	\(N\) is the total number of time points, \(\Delta\phi_{1,2}\) the phase difference, and \(\left| . \right|\)the absolute value.<br>
	This measure quantifies how consistent the phase difference between two signals is over time, ranging from 0 (no phase synchrony) to 1 (perfect synchrony). Noteworthy, \(A\) is not used in the defition of the \(\text{PLV}\) rendering this metric independent of the amplitude. Beware, that it is still dependent on the signal-to-noise ratio, but not the amplitude of the signal per se.
	$$\Phi_{\text{PLV}} = \arg \left( \frac{1}{N} \sum_{n=1}^{N} e^{i \Delta\phi_{1,2}(t)} \right)$$
	\(\arg(.)\) is the argument function, which gives the phase angle of the complex mean phase difference.<br>
	\(\Phi_{\text{PLV}}\) represents the preferred phase difference.<br>
	One can represent both information as a phasor in a polar plot, where its radius would be the \(\text{PLV}\) and \(\Phi_{\text{PLV}}\) its angle, that is:
	$$\mathcal{P}_{\text{PLV}} = \frac{1}{N} \sum_{t=1}^{N} e^{i \Delta\phi_{1,2}(t)} = \text{PLV}e^{i \Phi_{\text{PLV}}}$$	
	<p>
	The plot below let you modify \(f_2\), \(\theta_2\) and \(\sigma\) and see their effect on the \(\text{PLV}\).
	</section>
    <div id="plot" style="width:100%;height:600px;"></div>
	<div class="divfooter" id="myDivFooter">
		<span style="padding: 5px">
			<label for="frequency">\(f_2\) :</label>
			<input type="range" id="frequency" class="slider" min="1" max="25" value="10">
			<span id="freqValue">10 Hz</span>
		</span>
		<span style="padding: 5px">
			<label for="phase">\(\theta_2\) :</label>
			<input type="range" id="phase" class="slider" min="-175" max="180" value="0" step="5">
			<span id="phaseValue">0 rad</span>
		</span>
		<span style="padding: 5px">
			<label for="noiseLevel">\(\sigma\) :</label>
			<input type="range" id="noiseLevel" class="slider" min="0" max="1" value="0.1" step="0.01">
			<span id="noiseValue">0.1</span>
		</span>
		<span style="padding: 5px">
		Show: 
		<input type="checkbox" id="showPLV" checked /><label for="showPLV">PLV</label>
		<input type="checkbox" id="showiPLV"/><label for="showiPLV">iPLV</label>
		<input type="checkbox" id="showciPLV"/><label for="showicPLV">ciPLV</label>
		</span>
    </div>
	<section>
	<h2>Version of the Phase Locking Value robust to spatial leakage.</h2>
	In case of spatial leakage (signal mixing), such in Electrical Source Imaging, \(S_1\) and \(S_2\) can be spuriously correlated. However, this spurious correlation is instantaneous and thus occurs at 0-lag. One way to compensate for that is by removing the contribution to the 0-lag in the computation of the PLV. Importantly, 0-lag means that the phase difference equals 0. Any contribution at 0-lag happens on the real axis. Therefore the imaginary part of the PLV is defined as:
	$$\text{iPLV} = \Im\left( \mathcal{P}_{\text{PLV}} \right)$$<br>
	\(\Im\) is the imaginary part. 
	This metric is now robust to spurious 0-lag but also removes any genuine 0-lag. We cannot, however, estimate the true preferred phase due to the mixing. Intuitively, \(\text{iPLV}\) is the projection of the \(\text{PLV}\) phasor onto the imaginary axis. Check the \(\text{iPLV}\) box, and see how this metric behaves according to different changes in phase and noise.
	<br>
	<br>
	Unfortunately, \(\text{iPLV}\) is sensitive to the preferred phase difference \(\Phi_{\text{PLV}}\). A corrected version of \(\text{iPLV}\), named corrected iPLV, mitigates this effect and is defined as:
	$$\text{ciPLV} = \frac{\Im\left( \mathcal{P}_{\text{PLV}}\right)}{\sqrt{1-\Re\left( \mathcal{P}_{\text{PLV}} \right)^2}}$$<br>
	\(\Re\) is the real part.<br>
	Check the \(\text{ciPLV}\) box, and see how this metric behaves according to different changes in phase and noise.
	</section>
	
	
    <script type="module" async>
		import {computeDFT, generateGaussianNoise, analyticSignal, computePLV, computeiPLV, computeciPLV} from 'https://roehrin.github.io/webapps_for_EEG_courses/js-scripts/simpleSignalProcessing.js';
        
		const checkboxes = document.querySelectorAll('input[type=checkbox]');
		
        const sampleRate = 512;
		const freq1 = 10;
		const phase1 = 0;
		var freq2 = parseFloat(document.getElementById("frequency").value);
		var phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
		var noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
        const time = Array.from({ length: sampleRate }, (_, i) => i / sampleRate);
		
		var w1 = .65;
		var w2 = .25;
		var w3 = .05;
		var wgap = .05;
		// normalise the ws to ensure the sum equals 1
		let wnorm = w1 + w2 + w3 + 2*wgap;
		w1 = w1/wnorm; w2 = w2/wnorm; wgap = wgap/wnorm;
		
        
		// Generate noise
		var noise1 = generateGaussianNoise(noiseLvl, time.length); // Noise for first channel
		var noise2 = generateGaussianNoise(noiseLvl, time.length); // Second sine wave
		
		// Generate sine waves
		var sineWave1 = generateSineWave(freq1, phase1, noise1); // First sine wave
		var sineWave2 = generateSineWave(freq2, phase2, noise2); // Second sine wave
		
		// compute analytic signal
		var zWave1 = analyticSignal(sineWave1); // First sine wave
		var zWave2 = analyticSignal(sineWave2); // Second sine wave
		
		var instPhase1 = zWave1.map(([real, imag]) => Math.atan2(imag, real)); // Math.atan2(imag, real))
		var instPhase2 = zWave2.map(([real, imag]) => Math.atan2(imag, real));
		
        function generateSineWave(frequency, phase, noise) {
            return time.map((t, index) => Math.cos(2 * Math.PI * frequency * t + phase) + noise[index]);
        }
		
		frequency.oninput = function () {
			freq2 = parseFloat(document.getElementById("frequency").value);
			document.getElementById("freqValue").textContent = freq2 + " Hz";
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		
		phase.oninput = function () {
			phase2 = 2*Math.PI/360*parseFloat(document.getElementById("phase").value);
			document.getElementById("phaseValue").textContent = phase2.toFixed(2) + " rad";
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		
		noiseLevel.oninput = function () {
			noiseLvl = parseFloat(document.getElementById("noiseLevel").value);
			document.getElementById("noiseValue").textContent = noiseLvl.toFixed(2);
			
			noise1 = generateGaussianNoise(noiseLvl, time.length);
			sineWave1 = generateSineWave(freq1, phase1, noise1);
			zWave1 = analyticSignal(sineWave1);
			instPhase1 = zWave1.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			
			noise2 = generateGaussianNoise(noiseLvl, time.length);
			sineWave2 = generateSineWave(freq2, phase2, noise2);
			zWave2 = analyticSignal(sineWave2);
			instPhase2 = zWave2.map((cmplx, i) => Math.atan2(cmplx[1], cmplx[0]));
			updatePlots()
		}
		

        function updatePlots() {        
            
			const PLV = computePLV(instPhase1, instPhase2);
			const iPLV = computeiPLV(PLV);
			const ciPLV = computeciPLV(PLV)
			// to compute the angle diff we have to pass again to the complex values to stay within [-pi, pi]
			const angleDiff = instPhase1.map((ph1, i) => Math.atan2(Math.sin(ph1-instPhase2[i]),Math.cos(ph1-instPhase2[i]))); 
            // Create traces for time domain signals
            const timeTrace1 = {
                x: time,
                y: sineWave1,
                mode: 'lines',
				type: 'scatter',
                name: 'Signal 1',
                line: { color: 'black' }
            };

            const timeTrace2 = {
                x: time,
                y: sineWave2,
                mode: 'lines',
                name: 'Signal 2',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'}
            };
			
			// Create traces for instantaneous phase signals
            const instPhTrace1 = {
                x: time,
                y: instPhase1,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
				type: 'scatter',
                name: 'Inst. Phase, Wave 1',
                line: { color: 'black' },
				showlegend: false,
            };

            const instPhTrace2 = {
                x: time,
                y: instPhase2,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: 'Inst. Phase, Wave 2',
				type: 'scatter',
                line: { color: 'blue',dash: 'dashdot'},
				showlegend: false,
            };
			
			const instPhDiffTrace = {
                x: time,
                y: angleDiff,
                mode: 'lines',
				xaxis: 'x2',
				yaxis: 'y2',
                name: 'Phase diff.',
				type: 'scatter',
                line: { color: 'brown',dash: 'solid'},
				showlegend: true,
            };


            // Create scatter plot trace
            const scatterTrace = {
				type: "scatterpolar",
				r: new Array(angleDiff.length).fill(1),
				theta: angleDiff,
				mode: "markers",
				marker: {
					color: 'brown',//"#2255ff",
					size: 10,
					line: {
					  color: "white"
					},
					opacity: 0.1
				},
				thetaunit: "radians",
				cliponaxis: true,
				subplot: "polar",
				name: "Phase diff.",
			};
			
			
			// Create bar plot for correlation
			const plvPlot = [{
				type: "scatterpolar",
				name: `PLV (r = ${PLV.magnitude.toFixed(2)})`,
				r: [0, PLV.magnitude],
				theta: [0, PLV.phaseLocking],
				marker: {
					color: "orange",
					symbol: "square",
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showPLV.checked,
			},
			{
				type: "scatterpolar",
				name: `iPLV (r = ${iPLV.magnitude.toFixed(2)})`,
				r: [0, iPLV.magnitude],
				theta: [0, iPLV.phaseLocking],
				marker: {
					color: "green",
					symbol: 121,
					line: {
						width: 3
					},
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",				
				visible: showiPLV.checked,
			},
			{
				type: "scatterpolar",
				name: `ciPLV (r = ${ciPLV.magnitude.toFixed(2)})`,
				r: [0, ciPLV.magnitude],
				theta: [0, ciPLV.phaseLocking],
				marker: {
					color: "purple",
					symbol: 121,
					line: {
						width: 3
					},
					size: 15,
				},
				line: {
					color: "black",
					width: 5},
				thetaunit: "radians",
				subplot: "polar",
				visible: showciPLV.checked,
			}
			];
			
			// Define metric data
			const metricsData = {
				PLV: PLV.magnitude,
				iPLV: iPLV.magnitude,
				ciPLV: ciPLV.magnitude
			};
			
			var barValues = [];
			var barText = [];
			
			checkboxes.forEach(checkbox => {
				if (checkbox.checked) {
					barValues.push(metricsData[checkbox.id.substr(4)]);  // Store metric name
					barText.push(checkbox.id.substr(4)); // Store corresponding values
				}
			});
			
			// Create bar plot for correlation
			const barPlot = {
				x: barText,
				y: barValues,
				type: 'bar',
				xaxis: 'x3',
				yaxis: 'y3',
				name: 'Bar Plot',
				marker:{
					color: ['orange', 'green', 'purple']
				},
				showlegend: false
			};
			
            // Define subplots layout
            const layout = {
                //grid: { rows: subplotRows, columns: subplotCols, pattern: 'independent' },
				// time domain
                xaxis: { domain: [0, w1], anchor: 'y1'},
                yaxis: { title: 'Amplitude', domain: [.55, 1], anchor: 'x1', range: [-2, 2]},
				xaxis2: { title: 'Time (s)', domain: [0, w1], anchor: 'y2'},
                yaxis2: { title: 'Phase (rad)', domain: [0, .45], anchor: 'x2', range: [-Math.PI, Math.PI], 
							tickmode: "array", tickvals: [-Math.PI, -1/2*Math.PI, 0, 1/2*Math.PI, Math.PI],
							ticktext: ['-π', '-<sup>1</sup>⁄<sub>2</sub>π','0','<sup>1</sup>⁄<sub>2</sub>π','π']
						},				
				// bar plot
				xaxis3: { domain: [w1+w2+wgap, 1], anchor: 'y3'},
                yaxis3: { title: 'Magnitude', domain: [0, 1], side: 'right', anchor: 'x3', range: [0, 1]},
				
				// polar scatter
				polar: {domain: {x: [w1+wgap, w1+w2], y: [0, 1]}, angularaxis: {thetaunit: "radians"}, radialaxis: {range: [0, 1.1]}},
				showlegend: true,
				font: { size: 16 },
				legend: {x: 0, xanchor: 'left', y: 1, orientation: "h", font: { size: 16 }}
            };

            // Combine all traces into a single data array
            var combinedData = [
                timeTrace1,
                timeTrace2,
                instPhTrace1,
                instPhTrace2,
				instPhDiffTrace,
				scatterTrace,
				barPlot
            ];
			combinedData = combinedData.concat(plvPlot);

            // Update the plot
            Plotly.newPlot('plot', combinedData, layout, {responsive: true});
        }

        // Initial plot
        updatePlots();
		
		checkboxes.forEach(checkbox => {
            checkbox.addEventListener('click', updatePlots);
        });
				
    </script>
</body>
</html>
